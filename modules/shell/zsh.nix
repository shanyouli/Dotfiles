{ config, options, pkgs, lib, inputs, ... }:

with lib;
with lib.my;
let cfg = config.modules.shell.zsh;
in {
  options.modules.shell.zsh = with types; {
    fzf    = mkBoolOpt true;
    theme  = mkBoolOpt true;
    zinit  = mkBoolOpt true;
    zlua   = mkBoolOpt true;
    commandNotFound = mkBoolOpt true;

    aliases = mkOpt (attrsOf (either str path)) {};

    rcInit = mkOpt' lines "" ''
      Zsh lines to be written to $XDG_CONFIG_HOME/zsh/extra.zshrc and sourced by
      $XDG_CONFIG_HOME/zsh/.zshrc
    '';
    envInit = mkOpt' lines "" ''
      Zsh lines to be written to $XDG_CONFIG_HOME/zsh/extra.zshenv and sourced
      by $XDG_CONFIG_HOME/zsh/.zshenv
    '';
    prevInit = mkOpt' lines "" "zshrc pre";

    rcFiles  = mkOpt (listOf (either str path)) [];
    envFiles = mkOpt (listOf (either str path)) [];
  };

  config = mkMerge [
    {
      users.defaultUserShell = pkgs.zsh;
      programs.command-not-found = {
        enable = cfg.commandNotFound;
        dbPath = "${inputs.nixpkgs}/programs.sqlite";
      };
      programs.zsh = {
        enable = true;
        enableCompletion = true;
        # I init completion myself, because enableGlobalCompInit initializes it
        # too soon, which means commands initialized later in my config won't get
        # completion, and running compinit twice is slow.
        enableGlobalCompInit = false;
        promptInit = "";
      };
      env = {
        ZDOTDIR     = "$XDG_CONFIG_HOME/zsh";
        ZSH_CACHE   = "$XDG_CACHE_HOME/zsh";
      };
      user.packages = with pkgs; [
        zsh
        nix-zsh-completions
        bat
        exa
        fd
        grc
        unstable.bottom
        tealdeer # rust tldr
        zsh-nix-shell
        (mkIf cfg.zinit zinit)
      ];
      modules.shell.zsh = {
        prevInit = if cfg.zinit then ''
          zinit ice pick"nix-shell.plugin.zsh" wait"2" silent
          zinit load ${pkgs.zsh-nix-shell}/share/zsh-nix-shell
        '' else ''
          source ${pkgs.zsh-nix-shell}/share/zsh-nix-shell/nix-shell.plugin.zsh
        '';
        aliases.htop = "btm --basic";
      };
    }
    (mkIf cfg.fzf {
      user.packages = [ pkgs.fzf ];
      modules.shell.zsh.prevInit = if cfg.zinit then ''
        zinit ice wait"0" silent pick'completion.zsh' src'key-bindings.zsh'
        zinit load ${pkgs.fzf}/share/fzf
      '' else ''
        source ${pkgs.fzf}/share/fzf/completion.zsh
        source ${pkgs.fzf}/share/fzf/key-bindings.zsh
      '';
    })
    (mkIf cfg.zlua {
      user.packages = [ pkgs.z-lua ];
      modules.shell.zsh.prevInit = ''
        export _ZL_DATA=$ZSH_CACHE/zlua
        function _z() { _zlua "$@"; }
        _cache z --init zsh enhanced once ${optionalString cfg.fzf "echo fzf"}
      '';
    })
    (mkIf cfg.theme {
      user.packages = [ pkgs.zsh-powerlevel10k ];
      modules.shell.zsh.prevInit = let
        load= if cfg.zinit then ''
          zinit ice pick"*.zsh-theme" silent
          zinit load ${pkgs.zsh-powerlevel10k}/share/zsh-powerlevel10k
        '' else ''
          source ${pkgs.zsh-powerlevel10k}/share/zsh-powerlevel10k/powerlevel10k.zsh-theme
        '';
        in ''
          ${load}
          if [[ -n $DISPLAY  ]] ; then
            [[ -r "$ZDOTDIR"/p10k.zsh ]] && source "$ZDOTDIR"/p10k.zsh
          else
            [[ -r "$ZDOTDIR"/p10k.tty.zsh ]] && source "$ZDOTDIR"/p10k.tty.zsh
          fi
        '';
    })
    {
      home.configFile = {
        # Write it recursively so other modules can write files to it
        "zsh" = { source = "${configDir}/zsh"; recursive = true; };

        # Why am I creating extra.zsh{rc,env} when I could be using extraInit?
        # Because extraInit generates those files in /etc/profile, and mine just
        # write the files to ~/.config/zsh; where it's easier to edit and tweak
        # them in case of issues or when experimenting.
        "zsh/prev.zshrc".text = ''
          ${optionalString cfg.zinit ''
            source ${pkgs.zinit}/share/zinit/zinit.zsh
            module_path+=( ${pkgs.zinit}/share/zinit/zsh )
            zmodload zdharma/zplugin
            if [[ -n ''${aliases[zi]} ]]; then
              unalias zi zini zplg zpl
            fi
          ''}
          ${cfg.prevInit}
        '';
        "zsh/extra.zshrc".text =
          let aliasLines = mapAttrsToList (n: v: "alias ${n}=\"${v}\"") cfg.aliases;
          in ''
            # This file was autogenerated, do not edit it!
            ${concatStringsSep "\n" aliasLines}
            ${concatMapStrings (path: "source '${path}'\n") cfg.rcFiles}
            ${cfg.rcInit}
          '';

        "zsh/extra.zshenv".text = ''
          # This file is autogenerated, do not edit it!
          ${concatMapStrings (path: "source '${path}'\n") cfg.envFiles}
          ${cfg.envInit}
        '';
      };
      home.onReload.cleanupZsh = ''
        ${optionalString cfg.zinit ''
          find $XDG_CONFIG_HOME -name "*.zwc" -exec rm -rf {} \;
        ''}
        ${optionalString cfg.theme "rm -rf $XDG_CACHE_HOME/p10k*"}
        rm -rvf $XDG_CACHE_HOME/zsh/cache/*
      '';
    }
  ];
}
