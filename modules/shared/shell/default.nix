{
  config,
  options,
  pkgs,
  lib,
  ...
}:
with lib;
with lib.my; let
  cfg = config.modules.shell;
  getLastFunction = str: last (splitString "/" str);
  configDir = config.dotfiles.configDir;
  plFn = ext: l: (let
    _resultFn =
      if ext == "completions"
      then x: "${configDir}/${x}/_${x}"
      else x: "${configDir}/${x}/${x}.${ext}.zsh";
  in
    map (x:
      if hasPrefix "/" x
      then x
      else if hasInfix "/" x
      then "${configDir}/${x}"
      else _resultFn x)
    l);
  baseFunction = l: path:
    concatMapAttrs (n: v: {
      "${n}".source = v;
    }) (builtins.listToAttrs (map (value: {
        inherit value;
        name = "zsh/${path}/${getLastFunction value}";
      })
      l));
  my-nix-script = pkgs.stdenv.mkDerivation rec {
    name = "nix-scripts";
    src = ../../../bin;
    buildInputs = [];
    installPhase = ''
      mkdir -p $out/bin
      find . -maxdepth 1 -perm -a+x -not -name '*.*' \
        -exec cp -pL {} $out/bin \;
    '';

    meta = with lib; {
      description = "my scripts bin";
      homepage = https://github.com/shanyouli/system;
      license = licenses.mit;
      maintainers = with maintainers; [shanyouli];
      platforms = platforms.all;
    };
  };
in {
  options.modules.shell = with types; {
    aliases = mkOpt (attrsOf (either str path)) {};
    env = mkOption {
      type = attrsOf (oneOf [str path (listOf (either str path))]);
      apply = mapAttrs (n: v:
        if isList v
        then
          (
            if (strings.toUpper "${n}") == "PATH"
            then concatMapStringsSep " " toString v
            else concatMapStringsSep ":" toString v
          )
        else (toString v));
      default = {};
      description = "TODO";
    };
    rcInit = mkOpt' lines "" ''
      Zsh lines to be written to $XDG_CONFIG_HOME/zsh/extra.zshrc and sourced by
      $XDG_CONFIG_HOME/zsh/.zshrc
    '';
    envInit = mkOpt' lines "" ''
      Zsh lines to be written to $XDG_CONFIG_HOME/zsh/extra.zshenv and sourced
      by $XDG_CONFIG_HOME/zsh/.zshenv
    '';
    prevInit = mkOpt' lines "" "zshrc pre";
    envFiles = mkOptA (listOf (either str path)) [] (plFn "env");
    cmpFiles = mkOptA (listOf (either str path)) [] (plFn "completions");
    pluginFiles = mkOptA (listOf (either str path)) [] (plFn "plugin");
  };

  # 一些现代命令行工具的推荐:https://github.com/ibraheemdev/modern-unix
  config = {
    # lib.mkIf cfg.enable (lib.mkMerge [{ users.defaultUserShell = pkgs.zsh; }]);
    # only nixos
    # users.defaultUserShell = pkgs.zsh;
    user.shell = pkgs.stable.zsh;
    programs.zsh = {
      enable = true;
      # 我将自动启用bashcompinit 和compinit配置
      enableCompletion = false;
      enableBashCompletion = false;
      promptInit = "";
    };
    user.packages = with pkgs.stable; [
      bottom
      fd
      eza
      bat
      duf
      grc
      httrack # 网页抓取
      cachix # nix cache
      hugo # 我的blog工具
      imagemagick # 图片转换工具
      gifsicle # 命令行gif生成工具
      nix-your-shell # nix-shell Support for other shells(zsh,fish,nushell)

      atool # 解压工具
      unrar
      gnused # sed 工具
      coreutils-prefixed # GNUcoreutils 工具，mv，cp等

      tailspin # 支持高亮的语法查看工具
      pkgs.unstable.nvfetcher-bin # 管理自己构建包的升级

      fzf
      my-nix-script
      pkgs.unstable.python3.pkgs.sd
    ];
    env = {
      PATH = ["${config.home.binDir}"];
      ZDOTDIR = ''''${XDG_CONFIG_HOME:-~/.config}/zsh'';
      ZSH_CACHE = "${config.home.cacheDir}/zsh";
    };
    modules.shell = {
      envInit = mkOrder 100 ''
        # This file is autogenerated, do not edit it!
        ${concatStringsSep "\n" (mapAttrsToList (n: v: (
            if (strings.toUpper "${n}") == "PATH"
            then ''export path=( ${v} $path)''
            else ''export ${n}="${v}"''
          ))
          cfg.env)}
        ${optionalString (cfg.envFiles != []) ''
          for i in "$ZDOTDIR/env/"*.env.zsh; do
            source $i
          done
        ''}
        ZINIT[HOME_DIR]="$XDG_DATA_HOME/zinit"
        ZINIT[ZCOMPDUMP_PATH]="$ZSH_CACHE/zcompdump"
        ZINIT[COMPINIT_OPTS]="-C"
      '';
      prevInit = mkOrder 100 ''
        source ${pkgs.stable.grc}/etc/grc.zsh
        # FZF 配置
        FZF_DEFAULT_COMMAND="fd -H -I --type f"
        FZF_DEFAULT_OPTIONS="fd --height 50%"
        FZF_CTRL_T_COMMAND="fd -H -I --type f"
        FZF_CTRL_T_OPTS="--preview 'bat --color=always --plain --line-range=:200 {}'"
        FZF_ALT_C_COMMAND="fd -H -I --type d -E '.git*'"
        FZF_ALT_C_OPTS="--preview 'eza -T -L 2 {} | head -2000'"
        # FZF_CTRL_R_OPTS=""
        # source ${pkgs.stable.fzf}/share/fzf/completion.zsh
        # source ${pkgs.stable.fzf}/share/fzf/key-bindings.zsh

        ${lib.optionalString (! cfg.vivid.enable) ''
          # colors 配置 if'[[ -z $LS_COLORS ]]'
          zice 0a atcone="dircolors -b LS_COLORS > c.zsh" \
            atpull='%atclone' pick='c.zsh' \
            trapd00r/LS_COLORS
        ''}
      '';
      rcInit = mkOrder 100 ''
        _cache -v ${pkgs.stable.nix-your-shell.version} nix-your-shell zsh
        ${lib.optionalString (! cfg.atuin.enable) ''
          if [[ "$INSIDE_EMACS" != 'vterm' ]]; then
            _zt 0b light-mode for \
              compile'{hsmw-*,test/*}' \
              zdharma/history-search-multi-word \
              atload'bindkey -M viins "^n" history-substring-search-down;
              bindkey -M viins "^p" history-substring-search-up;
              bindkey "^[[A" history-substring-search-up;
              bindkey "^[[B" history-substring-search-down' \
              zsh-users/zsh-history-substring-search

            # history-search-multi-word config
            # # Color in which to highlight matched, searched text
            # (default bg=17 on 256-color terminals)
            zstyle ":history-search-multi-word" highlight-color "fg=yellow,bold"
            # Whether to perform syntax highlighting (default true)
            zstyle ":plugin:history-search-multi-word" synhl "yes"
            # Effect on active history entry. Try: standout, bold, bg=blue (default underline)
            zstyle ":plugin:history-search-multi-word" active "underline"
            # Whether to check paths for existence and mark with magenta (default true)
            zstyle ":plugin:history-search-multi-word" check-paths "yes"
            # Whether pressing Ctrl-C or ESC should clear entered query
            zstyle ":plugin:history-search-multi-word" clear-on-cancel "no"
          else
            bindkey '^r' fzf-history-widget
          fi
        ''}
        ${optionalString (! cfg.starship.enable) ''
          zinit ice depth=1
          zinit light romkatv/powerlevel10k
          if [[ "$INSIDE_EMACS" != 'vterm' ]]; then
            _source $ZDOTDIR/p10conf/default.zsh
          else
            _source $ZDOTDIR/p10conf/vterm.zsh
          fi
        ''}
        # alias 别名，设置
        ${concatStringsSep "\n" (mapAttrsToList (n: v: ''alias ${n}="${v}"'') cfg.aliases)}
      '';
      aliases.htop = "btm --basic --mem_as_value";
      aliases.df = "duf";
      aliases.cat = "bat -p"; #or  bat -pp
      aliases.unzip = "atool --extract --explain";
      aliases.zip = "atool --add";
      aliases.log = "tspin";
    };
    home.configFile =
      {
        "zsh".source = "${configDir}/zsh";
        "zsh".recursive = true;
        "zsh/cache/prev.zshrc".text = cfg.prevInit;
        "zsh/cache/extra.zshrc".text = cfg.rcInit;
        "zsh/cache/extra.zshenv".text = cfg.envInit;
        "zsh/.zshrc".text = ''
          source ${pkgs.unstable.zpmod}/share/zpmod/zpmod.plugin.zsh
          : ''${ZINIT_HOME:="''${XDG_DATA_HOME}/zinit/zinit.git"}
          ${lib.optionalString (! cfg.zinit.enable) ''
            [[ -d "''${ZINIT_HOME}" ]] || {
              mkdir -p $(dirname "''${ZINIT_HOME}")
              git clone --depth 1 https://github.com/zdharma-continuum/zinit.git "''${ZINIT_HOME}"
            }
          ''}
          ZINIT[BIN_DIR]="$ZINIT_HOME"
          _source "''${ZINIT_HOME}/zinit.zsh"

          _source "''${ZDOTDIR}/cache/prev.zshrc" \
            "''${ZDOTDIR}/zshrc.zsh" \
            "''${ZDOTDIR}/cache/extra.zshrc" \
            "''${HOME}/.zshrc"
        '';
      }
      // (baseFunction cfg.cmpFiles "completions")
      // (baseFunction cfg.pluginFiles "plugins")
      // (baseFunction cfg.envFiles "env");
  };
}
