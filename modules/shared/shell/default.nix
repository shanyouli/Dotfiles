{
  config,
  options,
  pkgs,
  lib,
  ...
}:
with lib;
with lib.my; let
  cfg = config.modules.shell;
  getLastFunction = str: last (splitString "/" str);
  configDir = config.dotfiles.configDir;
  cmpFunc = map (x:
    if hasPrefix "/" x
    then x
    else if hasInfix "/" x
    then "${configDir}/${x}"
    else "${configDir}/${x}/_${x}");
  pluginFunc = map (x:
    if hasPrefix "/" x
    then x
    else if hasInfix "/" x
    then "${configDir}/${x}"
    else "${configDir}/${x}/${x}.plugin.zsh");
  envFunc = map (x:
    if hasPrefix "/" x
    then x
    else if hasInfix "/" x
    then "${configDir}/${x}"
    else "${configDir}/${x}/${x}.env.zsh");
  baseFunction = l: path:
    concatMapAttrs (n: v: {
      "${n}".source = v;
    }) (builtins.listToAttrs (map (value: {
        inherit value;
        name = "zsh/${path}/${getLastFunction value}";
      })
      l));
in {
  options.modules.shell = with types; {
    aliases = mkOpt (attrsOf (either str path)) {};
    env = mkOption {
      type = attrsOf (oneOf [str path (listOf (either str path))]);
      apply = mapAttrs (n: v:
        if isList v
        then
          (
            if (strings.toUpper "${n}") == "PATH"
            then concatMapStringsSep " " toString v
            else concatMapStringsSep ":" toString v
          )
        else (toString v));
      default = {};
      description = "TODO";
    };
    rcInit = mkOpt' lines "" ''
      Zsh lines to be written to $XDG_CONFIG_HOME/zsh/extra.zshrc and sourced by
      $XDG_CONFIG_HOME/zsh/.zshrc
    '';
    envInit = mkOpt' lines "" ''
      Zsh lines to be written to $XDG_CONFIG_HOME/zsh/extra.zshenv and sourced
      by $XDG_CONFIG_HOME/zsh/.zshenv
    '';
    prevInit = mkOpt' lines "" "zshrc pre";
    envFiles = mkOptA (listOf (either str path)) [] envFunc;
    cmpFiles = mkOptA (listOf (either str path)) [] cmpFunc;
    pluginFiles = mkOptA (listOf (either str path)) [] pluginFunc;
  };

  # 一些现代命令行工具的推荐:https://github.com/ibraheemdev/modern-unix
  config = {
    # lib.mkIf cfg.enable (lib.mkMerge [{ users.defaultUserShell = pkgs.zsh; }]);
    # only nixos
    # users.defaultUserShell = pkgs.zsh;
    user.shell = pkgs.stable.zsh;
    programs.zsh = {
      enable = true;
      # 我将自动启用bashcompinit 和compinit配置
      enableCompletion = false;
      enableBashCompletion = false;
      promptInit = "";
    };
    user.packages = with pkgs; [
      stable.bottom
      stable.fd
      stable.eza
      stable.bat
      stable.duf
      stable.grc
      stable.httrack # 网页抓取
      stable.cachix # nix cache
      stable.hugo # 我的blog工具
      stable.imagemagick # 图片转换工具
      stable.gifsicle # 命令行gif生成工具

      stable.atool # 解压工具
      stable.unrar
      stable.gnused # sed 工具
      stable.coreutils-prefixed # GNUcoreutils 工具，mv，cp等
      (stable.sysdo.override {
        withZshCompletion = true;
        withRich = true;
      })

      stable.tailspin # 支持高亮的语法查看工具
      unstable.nvfetcher-bin # 管理自己构建包的升级

      stable.fzf
      stable.my-nix-script
    ];
    env = {
      PATH = ["${config.home.binDir}"];
      ZDOTDIR = ''''${XDG_CONFIG_HOME:-~/.config}/zsh'';
      ZSH_CACHE = "${config.home.cacheDir}/zsh";
    };
    modules.shell = {
      envInit = mkOrder 100 ''
        # This file is autogenerated, do not edit it!
        ${concatStringsSep "\n" (mapAttrsToList (n: v: (
            if (strings.toUpper "${n}") == "PATH"
            then ''export path=( ${v} $path)''
            else ''export ${n}="${v}"''
          ))
          cfg.env)}
        ${optionalString (cfg.envFiles != []) ''
          for i in "$ZDOTDIR/env/"*.env.zsh; do
            source $i
          done
        ''}
        ZINIT[HOME_DIR]="$XDG_DATA_HOME/zinit"
        ZINIT[ZCOMPDUMP_PATH]="$ZSH_CACHE/zcompdump"
        ZINIT[COMPINIT_OPTS]="-C"
      '';
      prevInit = mkOrder 100 ''
        source ${pkgs.stable.grc}/etc/grc.zsh
        # FZF 配置
        FZF_DEFAULT_COMMAND="fd -H -I --type f"
        FZF_DEFAULT_OPTIONS="fd --height 50%"
        FZF_CTRL_T_COMMAND="fd -H -I --type f"
        FZF_CTRL_T_OPTS="--preview 'bat --color=always --plain --line-range=:200 {}'"
        FZF_ALT_C_COMMAND="fd -H -I --type d -E '.git*'"
        FZF_ALT_C_OPTS="--preview 'eza -T -L 2 {} | head -2000'"
        # FZF_CTRL_R_OPTS=""
        # source ${pkgs.stable.fzf}/share/fzf/completion.zsh
        # source ${pkgs.stable.fzf}/share/fzf/key-bindings.zsh

        ${lib.optionalString (! cfg.vivid.enable) ''
          # colors 配置 if'[[ -z $LS_COLORS ]]'
          zice 0a atcone="dircolors -b LS_COLORS > c.zsh" \
            atpull='%atclone' pick='c.zsh' \
            trapd00r/LS_COLORS
        ''}
      '';
      rcInit = mkOrder 100 ''
        # starship和p10有自己的提示方法；--info-right
        _cache -v ${pkgs.stable.any-nix-shell.version} ${pkgs.stable.any-nix-shell}/bin/any-nix-shell zsh
        ${lib.optionalString (! cfg.atuin.enable) ''
          if [[ "$INSIDE_EMACS" != 'vterm' ]]; then
            _zt 0b light-mode for \
              compile'{hsmw-*,test/*}' \
              zdharma/history-search-multi-word \
              atload'bindkey -M viins "^n" history-substring-search-down;
              bindkey -M viins "^p" history-substring-search-up;
              bindkey "^[[A" history-substring-search-up;
              bindkey "^[[B" history-substring-search-down' \
              zsh-users/zsh-history-substring-search

            # history-search-multi-word config
            # # Color in which to highlight matched, searched text
            # (default bg=17 on 256-color terminals)
            zstyle ":history-search-multi-word" highlight-color "fg=yellow,bold"
            # Whether to perform syntax highlighting (default true)
            zstyle ":plugin:history-search-multi-word" synhl "yes"
            # Effect on active history entry. Try: standout, bold, bg=blue (default underline)
            zstyle ":plugin:history-search-multi-word" active "underline"
            # Whether to check paths for existence and mark with magenta (default true)
            zstyle ":plugin:history-search-multi-word" check-paths "yes"
            # Whether pressing Ctrl-C or ESC should clear entered query
            zstyle ":plugin:history-search-multi-word" clear-on-cancel "no"
          else
            bindkey '^r' fzf-history-widget
          fi
        ''}
        ${optionalString (! cfg.starship.enable) ''
          zinit ice depth=1
          zinit light romkatv/powerlevel10k
          if [[ "$INSIDE_EMACS" != 'vterm' ]]; then
            _source $ZDOTDIR/p10conf/default.zsh
          else
            _source $ZDOTDIR/p10conf/vterm.zsh
          fi
        ''}
        # alias 别名，设置
        ${concatStringsSep "\n" (mapAttrsToList (n: v: ''alias ${n}="${v}"'') cfg.aliases)}
      '';
      aliases.htop = "btm --basic --mem_as_value";
      aliases.df = "duf";
      aliases.cat = "bat -p"; #or  bat -pp
      aliases.unzip = "atool --extract --explain";
      aliases.zip = "atool --add";
      aliases.log = "tspin";
    };
    home.configFile =
      {
        "zsh".source = "${configDir}/zsh";
        "zsh".recursive = true;
        "zsh/cache/prev.zshrc".text = cfg.prevInit;
        "zsh/cache/extra.zshrc".text = cfg.rcInit;
        "zsh/cache/extra.zshenv".text = cfg.envInit;
        "zsh/.zshrc".text = ''
          source ${pkgs.stable.zpmod}/share/zpmod/zpmod.plugin.zsh
          : ''${ZINIT_HOME:="''${XDG_DATA_HOME}/zinit/zinit.git"}
          ${lib.optionalString (! cfg.zinit.enable) ''
            [[ -d "''${ZINIT_HOME}" ]] || {
              mkdir -p $(dirname "''${ZINIT_HOME}")
              git clone --depth 1 https://github.com/zdharma-continuum/zinit.git "''${ZINIT_HOME}"
            }
          ''}
          ZINIT[BIN_DIR]="$ZINIT_HOME"
          _source "''${ZINIT_HOME}/zinit.zsh"

          _source "''${ZDOTDIR}/cache/prev.zshrc" \
            "''${ZDOTDIR}/zshrc.zsh" \
            "''${ZDOTDIR}/cache/extra.zshrc" \
            "''${HOME}/.zshrc"
        '';
      }
      // (baseFunction cfg.cmpFiles "completions")
      // (baseFunction cfg.pluginFiles "plugins")
      // (baseFunction cfg.envFiles "env");
  };
}
